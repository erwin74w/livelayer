<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Livestream Overlay 1 (Logo)</title>
    <link rel="stylesheet" href="overlay.css">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
    <img id="logo" src="" alt="Stream Logo Loading...">

    <script>
        const urlParamsOverlay = new URLSearchParams(window.location.search);
        const userIdForThisOverlay = urlParamsOverlay.get('user');
        const LOG_PREFIX = `Overlay1 (Logo) for User [${userIdForThisOverlay || 'NO_USER_ID_PARAM'}]:`;

        console.log(LOG_PREFIX, "Script started. Raw query string:", window.location.search);

        const logoImg = document.getElementById('logo');
        const defaultRepoImagePathPrefix = '../pictures/';
        const defaultLogoFilename = 'overlay1.png';
        const defaultLogoUrl = defaultRepoImagePathPrefix + defaultLogoFilename;

        let supabaseClient = null;
        let logoRealtimeChannel = null;

        if (!userIdForThisOverlay) {
            console.error(LOG_PREFIX, "CRITICAL: Missing 'user' query parameter. Overlay will use default.");
            if(logoImg) {
                logoImg.src = defaultLogoUrl;
                logoImg.alt = "Configuration Error: User ID missing.";
            }
        }

        async function initializeSupabaseForOverlay() {
            console.log(LOG_PREFIX, "Attempting to initialize Supabase client...");
            try {
                const response = await fetch('../keys.json');
                console.log(LOG_PREFIX, "'keys.json' fetch status:", response.status);
                if (!response.ok) {
                    let errorText = "Could not retrieve response text.";
                    try { errorText = await response.text(); } catch(e) { /* ignore */ }
                    throw new Error(`HTTP ${response.status} fetching keys.json. Body: ${errorText}`);
                }
                const keys = await response.json();
                if (!keys.supabaseUrl || !keys.supabaseAnonKey || keys.supabaseUrl.includes("YOUR_ACTUAL") || keys.supabaseAnonKey.includes("YOUR_ACTUAL")) {
                    throw new Error("Supabase URL or Anon Key is missing/placeholder in keys.json.");
                }
                const { createClient } = supabase; // supabase global from CDN
                supabaseClient = createClient(keys.supabaseUrl, keys.supabaseAnonKey); // Use ANON key
                console.log(LOG_PREFIX, "Supabase client initialized.");
                return true;
            } catch (error) {
                console.error(LOG_PREFIX, "Failed to initialize Supabase:", error.message, error);
                if(logoImg) logoImg.alt = "Service Connection Error";
                return false;
            }
        }

        function updateLogoSrc(urlFromConfig, source = "Unknown") {
            console.log(LOG_PREFIX, `updateLogoSrc called from [${source}]. Received URL:`, urlFromConfig);
            let finalUrl = defaultLogoUrl; // Default if nothing else works

            if (urlFromConfig) {
                if (/^(https?:)?\/\//i.test(urlFromConfig)) { // Absolute URL
                    finalUrl = urlFromConfig;
                } else if (urlFromConfig.startsWith('../') || urlFromConfig.startsWith('./')) { // Already relative from this file's location
                    finalUrl = urlFromConfig;
                } else if (urlFromConfig.startsWith('/')) { // Absolute path from domain root
                     finalUrl = urlFromConfig;
                } else if (urlFromConfig.includes('/')) { // e.g., "pictures/new.png" -> needs to become "../pictures/new.png"
                     finalUrl = '../' + urlFromConfig;
                } else { // Just a filename "new.png", assume it's in the default repo image path
                    finalUrl = defaultRepoImagePathPrefix + urlFromConfig;
                }
            }
            
            console.log(LOG_PREFIX, `Setting logo src to: ${finalUrl}`);
            if (logoImg) {
                logoImg.src = ""; // Clear src first
                logoImg.src = finalUrl;
                logoImg.alt = `Logo: ${finalUrl.substring(finalUrl.lastIndexOf('/') + 1)}`;
                logoImg.onerror = () => {
                    console.error(LOG_PREFIX, `Error loading image: ${finalUrl}. Displaying default placeholder or broken image icon.`);
                    // To prevent infinite error loop if defaultLogoUrl itself is broken:
                    if (logoImg.src !== defaultLogoUrl) {
                         logoImg.src = defaultLogoUrl;
                         logoImg.alt = `Image not found. Default shown.`;
                    } else {
                        logoImg.alt = `Default image also failed to load.`;
                    }
                };
                logoImg.onload = () => {
                    console.log(LOG_PREFIX, `Image loaded successfully: ${finalUrl}`);
                };
            } else {
                console.error(LOG_PREFIX, "Logo image element not found in DOM.");
            }
        }

        async function fetchInitialLogoConfig() {
            if (!supabaseClient || !userIdForThisOverlay) {
                console.warn(LOG_PREFIX, "Cannot fetch initial config: Supabase not ready or no user ID.");
                updateLogoSrc(null, "FetchInitialConfig-PreSupabaseOrNoUser");
                return;
            }
            console.log(LOG_PREFIX, "Fetching initial logo data for user_id:", userIdForThisOverlay);
            try {
                const { data, error, status } = await supabaseClient
                    .from('overlay_configurations')
                    .select('config_data')
                    .eq('overlay_type', 'logo')
                    .eq('user_id', userIdForThisOverlay)
                    .maybeSingle();

                console.log(LOG_PREFIX, "Initial fetch Supabase response status:", status);
                if (error) {
                    console.error(LOG_PREFIX, 'Error fetching initial logo config:', error);
                    updateLogoSrc(null, "FetchInitialConfig-Error");
                } else if (data && data.config_data && typeof data.config_data.url === 'string') { // Check if url is a string
                    console.log(LOG_PREFIX, "Initial logo config loaded from DB:", data.config_data);
                    updateLogoSrc(data.config_data.url, "FetchInitialConfig-Success");
                } else {
                    console.log(LOG_PREFIX, "No initial logo config in DB or URL missing/invalid, using default. Data:", data);
                    updateLogoSrc(null, "FetchInitialConfig-NoDataOrInvalid");
                }
            } catch (fetchError) {
                console.error(LOG_PREFIX, 'Exception during Supabase initial fetch for logo:', fetchError);
                updateLogoSrc(null, "FetchInitialConfig-Exception");
            }
        }

        function setupRealtimeSubscription() {
            if (!supabaseClient || !userIdForThisOverlay) {
                console.warn(LOG_PREFIX, "Cannot setup Realtime: Supabase not ready or no user ID.");
                return;
            }
            if (logoRealtimeChannel) {
                console.log(LOG_PREFIX, "Removing existing Realtime channel before re-subscribing.");
                supabaseClient.removeChannel(logoRealtimeChannel)
                    .then(() => console.log(LOG_PREFIX, "Old Realtime channel removed."))
                    .catch(err => console.error(LOG_PREFIX, "Error removing old Realtime channel:", err));
                logoRealtimeChannel = null;
            }

            const realtimeChannelName = `logo-config-user-${userIdForThisOverlay}`;
            const realtimeFilter = `overlay_type=eq.logo&user_id=eq.${userIdForThisOverlay}`;
            console.log(LOG_PREFIX, `Attempting to subscribe to Realtime channel '${realtimeChannelName}' with filter '${realtimeFilter}'...`);

            logoRealtimeChannel = supabaseClient
                .channel(realtimeChannelName)
                .on(
                    'postgres_changes',
                    { event: '*', schema: 'public', table: 'overlay_configurations', filter: realtimeFilter },
                    (payload) => {
                        console.log(LOG_PREFIX, 'Realtime: Event received! Type:', payload.eventType, 'Payload:', JSON.parse(JSON.stringify(payload)));
                        if (payload.eventType === 'DELETE') {
                            console.log(LOG_PREFIX, "Realtime: Config DELETE event, using default logo.");
                            updateLogoSrc(null, "Realtime-Delete");
                        } else if (payload.new && payload.new.config_data && typeof payload.new.config_data.url === 'string') {
                            console.log(LOG_PREFIX, "Realtime: Applying new logo URL from payload:", payload.new.config_data.url);
                            updateLogoSrc(payload.new.config_data.url, "Realtime-Update");
                        } else {
                            console.log(LOG_PREFIX, "Realtime: Received payload not matching expected update/delete structure or URL invalid/missing. Current data:", payload.new, "Using default.");
                            updateLogoSrc(null, "Realtime-InvalidPayload");
                        }
                    }
                )
                .subscribe((status, err) => {
                    console.log(LOG_PREFIX, `Realtime: Subscription status for channel '${realtimeChannelName}': ${status}`);
                    if (status === 'SUBSCRIBED') {
                        console.log(LOG_PREFIX, 'Realtime: Successfully subscribed to logo config changes!');
                    } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
                        console.error(LOG_PREFIX, `Realtime: Subscription error: ${status}`, err);
                    } else if (status === 'CLOSED') {
                        console.log(LOG_PREFIX, 'Realtime: Subscription channel closed.');
                    }
                });
        }

        async function main() {
            console.log(LOG_PREFIX, "main() called.");
            if (!userIdForThisOverlay) {
                updateLogoSrc(null, "Main-NoUserID");
                return;
            }
            const supabaseReady = await initializeSupabaseForOverlay();
            if (supabaseReady) {
                await fetchInitialLogoConfig();
                setupRealtimeSubscription();
            } else {
                updateLogoSrc(null, "Main-SupabaseInitFail");
            }
        }

        main();

        window.addEventListener('beforeunload', async () => {
            console.log(LOG_PREFIX, "'beforeunload' event triggered.");
            if (logoRealtimeChannel && supabaseClient) {
                console.log(LOG_PREFIX, "Attempting to remove Realtime channel on unload.");
                try {
                    const status = await supabaseClient.removeChannel(logoRealtimeChannel);
                    console.log(LOG_PREFIX, "Realtime channel removal status on unload:", status);
                } catch(e) {
                    console.error(LOG_PREFIX, "Error removing Realtime channel on unload:", e);
                }
            }
        });
    </script>
</body>
</html>
