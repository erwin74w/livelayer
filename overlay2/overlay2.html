<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ticker Overlay (Supabase)</title>
    <link rel="stylesheet" href="overlay2.css">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
    <div id="ticker-container">
        <div id="ticker-text">Loading ticker...</div>
    </div>

    <script>
        const urlParamsOverlay = new URLSearchParams(window.location.search);
        const userIdForThisOverlay = urlParamsOverlay.get('user');
        const LOG_PREFIX = `Overlay2 (Ticker) for User ${userIdForThisOverlay || 'UNKNOWN'}:`;
        console.log(LOG_PREFIX, "Script started.");

        if (!userIdForThisOverlay) {
            console.error(LOG_PREFIX, "CRITICAL: Missing 'user' query parameter in URL. Overlay will not function.");
            document.getElementById('ticker-text').textContent = "Error: User ID missing.";
            // Optionally throw new Error("Missing user ID for Ticker Overlay");
        }

        const tickerTextElement = document.getElementById('ticker-text');
        const defaultTickerData = { messages: ["Ticker not configured..."], separator: " +++ " };
        let supabaseClient = null;
        let tickerChannel = null;

        async function initializeSupabase() {
            console.log(LOG_PREFIX, "Attempting to initialize Supabase...");
            try {
                const response = await fetch('../keys.json'); // Path relative to overlay2.html
                console.log(LOG_PREFIX, "Fetched keys.json, status:", response.status);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status} fetching keys.json`);
                const keys = await response.json();
                if (!keys.supabaseUrl || !keys.supabaseAnonKey || keys.supabaseUrl.includes("YOUR_ACTUAL") || keys.supabaseAnonKey.includes("YOUR_ACTUAL")) {
                    throw new Error("Supabase URL or Anon Key is missing/not configured in keys.json.");
                }
                const { createClient } = supabase; // supabase is global from CDN
                supabaseClient = createClient(keys.supabaseUrl, keys.supabaseAnonKey); // Use ANON key
                console.log(LOG_PREFIX, "Supabase client initialized successfully.");
                return true;
            } catch (error) {
                console.error(LOG_PREFIX, "Failed to initialize Supabase:", error.message, error);
                return false;
            }
        }

        function displayTicker(data) {
            const currentData = (data && data.messages && data.messages.length > 0) ? data : defaultTickerData;
            console.log(LOG_PREFIX, "Displaying ticker with data:", currentData);
            const separator = currentData.separator || " â€¢ ";
            let fullTickerString = currentData.messages.join(separator);

            tickerTextElement.style.animation = 'none'; // Stop existing animation
            tickerTextElement.offsetHeight; // Force reflow/repaint

            tickerTextElement.textContent = fullTickerString + separator + fullTickerString; // Duplicate for seamless scroll

            tickerTextElement.style.animation = ''; // Re-apply CSS animation
            console.log(LOG_PREFIX, "Ticker display updated and animation reset.");
        }

        async function loadAndListenForTickerChanges() {
            console.log(LOG_PREFIX, "loadAndListenForTickerChanges called.");
            if (!userIdForThisOverlay) {
                 console.warn(LOG_PREFIX, "Cannot load/listen, userIdForThisOverlay is missing.");
                 displayTicker(null); // Use default
                 return;
            }

            if (!supabaseClient) {
                const initialized = await initializeSupabase();
                if (!initialized) {
                    console.warn(LOG_PREFIX, "Supabase init failed during load/listen, using default ticker data.");
                    displayTicker(null); // Use default
                    return;
                }
            }

            // Initial load
            console.log(LOG_PREFIX, "Attempting initial data load for user:", userIdForThisOverlay);
            try {
                const { data, error } = await supabaseClient
                    .from('overlay_configurations')
                    .select('config_data')
                    .eq('overlay_type', 'ticker')
                    .eq('user_id', userIdForThisOverlay) // Filter by user_id
                    .maybeSingle();

                if (error) {
                    console.error(LOG_PREFIX, "Error loading initial content:", error);
                    displayTicker(null);
                } else if (data && data.config_data) {
                    console.log(LOG_PREFIX, "Initial config loaded from DB:", data.config_data);
                    displayTicker(data.config_data);
                } else {
                    console.log(LOG_PREFIX, "No initial config in DB or data malformed for this user, using default.");
                    displayTicker(null);
                }
            } catch (fetchError) {
                 console.error(LOG_PREFIX, "Supabase initial fetch error:", fetchError);
                 displayTicker(null);
            }

            // Subscribe to future changes
            if (tickerChannel) {
                console.log(LOG_PREFIX, "Removing existing Realtime channel before re-subscribing.");
                try { await supabaseClient.removeChannel(tickerChannel); } catch (e) { console.error(LOG_PREFIX, "Error removing old channel:", e); }
                tickerChannel = null;
            }

            const channelName = `ticker-config-changes-user-${userIdForThisOverlay}`;
            console.log(LOG_PREFIX, `Attempting to subscribe to Realtime channel '${channelName}' for 'ticker' and user ${userIdForThisOverlay}...`);
            tickerChannel = supabaseClient
                .channel(channelName)
                .on(
                    'postgres_changes',
                    {
                        event: '*',
                        schema: 'public',
                        table: 'overlay_configurations',
                        filter: `overlay_type=eq.ticker&user_id=eq.${userIdForThisOverlay}` // Filter Realtime by user_id and type
                    },
                    (payload) => {
                        console.log(LOG_PREFIX, 'Realtime: Ticker config change received! Payload:', payload);
                        if (payload.eventType === 'DELETE' || !payload.new || !payload.new.config_data) {
                            console.log(LOG_PREFIX, "Realtime: Delete event or no new data, using default ticker.");
                            displayTicker(null);
                        } else if (payload.new.config_data) {
                            console.log(LOG_PREFIX, "Realtime: Applying new ticker data:", payload.new.config_data);
                            displayTicker(payload.new.config_data);
                        } else {
                            console.log(LOG_PREFIX, "Realtime: New data malformed, using default ticker.");
                            displayTicker(null);
                        }
                    }
                )
                .subscribe((status, err) => {
                    console.log(LOG_PREFIX, `Realtime: Subscription status for ${channelName}: ${status}`);
                    if (status === 'SUBSCRIBED') console.log(LOG_PREFIX, 'Realtime: Successfully subscribed!');
                    if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') console.error(LOG_PREFIX, `Realtime: Subscription error: ${status}`, err);
                    if (status === 'CLOSED') console.log(LOG_PREFIX, 'Realtime: Subscription closed.');
                });
        }

        // Start the process only if userIdForThisOverlay is present
        if (userIdForThisOverlay) {
            loadAndListenForTickerChanges();
        }

        window.addEventListener('beforeunload', async () => {
            console.log(LOG_PREFIX, "beforeunload event.");
            if (tickerChannel && supabaseClient) {
                console.log(LOG_PREFIX, "Attempting to remove Realtime channel on unload.");
                try { await supabaseClient.removeChannel(tickerChannel); } catch(e) { console.error(LOG_PREFIX, "Error removing channel on unload:", e); }
            }
        });
    </script>
</body>
</html>
